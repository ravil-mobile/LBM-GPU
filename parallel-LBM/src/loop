for (int time = 0; time < parameters.num_time_steps; ++time) {
                  
        StreamDevice<<<NUM_BLOCKS, NUM_THREADS>>>(dev_population,
                                                  dev_swap_buffer,
                                                  dev_flag_field);
        //HANDLE_ERROR(cudaDeviceSynchronize());

        HANDLE_ERROR(cudaMemcpy(swap_buffer,
                                dev_swap_buffer,
                                parameters.num_lattices * parameters.discretization * sizeof(real),
                                cudaMemcpyDeviceToHost));
        
        TreatBoundary(boundary_update,
                      boundary_coords,
                      num_boundaries,
                      swap_buffer,
                      velocity,
                      density);
        
        HANDLE_ERROR(cudaMemcpy(dev_swap_buffer,
                                swap_buffer,
                                parameters.num_lattices * parameters.discretization * sizeof(real),
                                cudaMemcpyHostToDevice));
        
        //INCLUDE SYNCHRONIZATION HERE 
        std::swap(population, swap_buffer);
        std::swap(dev_population, dev_swap_buffer);
        
        
        UpdateDensityFieldDevice<<<NUM_BLOCKS, NUM_THREADS>>>(dev_density,
                                                              dev_population,
                                                              dev_flag_field); 
        //HANDLE_ERROR(cudaDeviceSynchronize());
        

        UpdateVelocityFieldDevice<<<NUM_BLOCKS, NUM_THREADS>>>(dev_velocity,
                                                               dev_population,
                                                               dev_density,
                                                               dev_flag_field);
        //HANDLE_ERROR(cudaDeviceSynchronize());
        

        UpdatePopulationFieldDevice<<<NUM_BLOCKS, NUM_THREADS>>>(dev_velocity,
                                                                 dev_population,
                                                                 dev_density);
        //INCLUDE SYNCHRONIZATION HERE
        //HANDLE_ERROR(cudaDeviceSynchronize());

        
        HANDLE_ERROR(cudaMemcpy(density,
                                dev_density,
                                parameters.num_lattices * sizeof(real),
                                cudaMemcpyDeviceToHost));
        
        HANDLE_ERROR(cudaMemcpy(velocity,
                                dev_velocity,
                                parameters.num_lattices * parameters.dimension * sizeof(real),
                                cudaMemcpyDeviceToHost));
        
        HANDLE_ERROR(cudaMemcpy(population,
                                dev_population,
                                parameters.num_lattices * parameters.discretization * sizeof(real),
                                cudaMemcpyDeviceToHost));
        

        #ifdef DEBUG
        real max_density = *std::max_element(density,
                                    density + parameters.num_lattices);
        real min_density = *std::min_element(density,
                                density + parameters.num_lattices);


        std::cout << "time step: " << time << "; ";
        std::cout << "max density: " << max_density << "; ";
        std::cout << "min density "  << min_density << std::endl;
#endif

#ifdef GRAPHICS
        if ((time % parameters.steps_per_report) == 0) {
            DisplayResults(velocity, velocity_frame);
            // DisplayResults(velocity, velocity_frame,
            //               density, density_frame);
        }
#endif
    }